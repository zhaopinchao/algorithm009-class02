学习笔记
### array数组

初始化： int[] array = new  int[n]; n为数组长度。

数组特性：

1. 访问效率高，可以用数组下标进行直接访问，时间复杂度为O(n)
2. 插入删除元素，效率低，时间复杂度O(n)。原因是当插入一个元素时，需要将插入位置后的所有元素往后移动一位(末尾插入则不需要移动元素)；当删除一个元素时，删除位置后面所有的元素都需要往前移动一位

### LinkedList链表

链表有单向链表、双向链表、循环链表(头尾相连)

链表特性：

1. 插入删除元素效率高，时间复杂度O(1)。插入删除元素时，只需要改动相关元素的next和pre指针即可。
2. 访问效率低，必须要遍历链表来进行查询，时间负责度O(n)

### 跳表 skipList

注：跳表只能使用与元素有序的情况

特性：插入、删除、搜索时间复杂度都是O(logn)

优点：原理简单，容易实现，方便扩展，效率更高，可以用来替代平衡树。例如：redis、levelDB都使用了skipList

思想：跳表实现加速，是在一维数据结构上进行升维做到的(以空间换时间)。

### 总结：

1、数组和链表各有各的特点，存在随机访问多，中间插入和删除操作少时可使用数组，存在插入删除操作多，随机访问少时，可使用链表。

2、一维数据结构要加速，通常使用的方式就是升维，变成二维数组，以空间换时间

### Queue 源码分析

队列通常是FIFO(先进先出)的方式对元素进行排序，但不一定都是。例如：优先级队列根据元素自身比较器进行排序、LIFO队列(后进先出)，无论是哪种队列，每个Queue都必须制定其排序属性

```
public interface Queue<E> extends Collection<E>
```

Queue是一个接口，定义了一些方法，如下：

| 方法名             | 说明                                           | 抛异常情况                                                   |
| ------------------ | ---------------------------------------------- | ------------------------------------------------------------ |
| boolean add(E e)   | 向队列的末尾新增一个元素，队列满时抛异常       | add的元素是null时、队列插入非指定类型元素时、优先级队列插入的元素没有实现Comparable接口时、队列满了的时候需要看队列的具体实现 |
| boolean offer(E e) | 向队列的末尾新增一个元素，队列满时返回false    | add的元素是null时、队列插入非指定类型元素时、优先级队列插入的元素没有实现Comparable接口时 |
| E remove()         | 删除并返回队列第一个元素，元素不存在时抛异常   | 元素不存在时                                                 |
| E poll()           | 删除并返回队列第一个元素，元素不存在时返回null |                                                              |
| E element()        | 获取队列的第一个元素，空队列时抛异常           | 队列为空时                                                   |
| E peek()           | 获取队列的第一个元素，空队列时返回null         |                                                              |

### PriorityQueue源码分析

优先级队列，队列的排序根据元素自身比较器规则进行排序

优先级队列，内部存储元素使用的是array数组，内部数组的扩容与ArrayList类似，数组的最大长度是Integer.MAX_VALUE。

优先级队列比较器的定义方式有两种，一个是初始化队列时，将比较器传入构造器中，一种是元素本身实现比较器接口。

入队和出队操作看的不是很明白……

